## 第2部分：CUDA热身2：并行前缀和 (10分)

既然你已经熟悉了CUDA程序的基本结构和布局，作为第二个练习，要求你编写`find_repeats`函数的并行实现。该函数接收一个整数列表`A`，返回所有满足`A[i] == A[i+1]`的索引`i`组成的列表。

例如，给定数组`{1,2,2,1,1,1,3,5,3,3}`，你的程序应该输出数组`{1,3,4,8}`。

#### 排他性前缀和

我们希望你通过首先实现并行排他性前缀和操作来实现`find_repeats`。

排他性前缀和接受一个数组`A`并生成一个新的数组`output`，在每个索引`i`处包含直到但不包括`A[i]`的所有元素之和。例如，给定数组`A={1,4,6,8,2}`，排他性前缀和的输出为`output={0,1,5,11,19}`。

以下“类似C”的代码是扫描操作的一个迭代版本。在伪代码中，我们使用`parallel_for`表示潜在的并行循环。这是课堂上讨论过的相同算法：<http://cs149.stanford.edu/fall24/lecture/dataparallel/slide_17>

```c
void exclusive_scan_iterative(int* start, int* end, int* output) {

    int N = end - start;
    memmove(output, start, N*sizeof(int));

    // 上升阶段
    for (int two_d = 1; two_d <= N/2; two_d*=2) {
        int two_dplus1 = 2*two_d;
        parallel_for (int i = 0; i < N; i += two_dplus1) {
            output[i+two_dplus1-1] += output[i+two_d-1];
        }
    }

    output[N-1] = 0;

    // 下降阶段
    for (int two_d = N/2; two_d >= 1; two_d /= 2) {
        int two_dplus1 = 2*two_d;
        parallel_for (int i = 0; i < N; i += two_dplus1) {
            int t = output[i+two_d-1];
            output[i+two_d-1] = output[i+two_dplus1-1];
            output[i+two_dplus1-1] += t;
        }
    }
}
```

我们希望你用这个算法在CUDA中实现一个版本的并行前缀和。你需要在`scan/scan.cu`中实现`exclusive_scan`函数。你的实现将包含主机端和设备端代码。实现将需要多次CUDA内核启动（对于伪代码中的每个`parallel_for`循环）。

**注意：** 在起始代码中，参考解决方案扫描实现假设输入数组长度（`N`）是2的幂。在`cudaScan`函数中，我们通过将输入数组长度四舍五入到最接近的2的幂来解决这个问题，当分配GPU上的相应缓冲区时。但是，代码只从GPU缓冲区复制回`N`个元素到CPU缓冲区。这个事实应该简化你的CUDA实现。

编译后生成二进制文件`cudaScan`。命令行用法如下：

```
用法: ./cudaScan [选项]

程序选项:
  -m  --test <TYPE>      在输入上运行指定的功能。有效的测试有: scan, find_repeats (默认: scan)
  -i  --input <NAME>     在给定输入类型上运行测试。有效的输入有: ones, random (默认: random)
  -n  --arraysize <INT>  数组中的元素数量
  -t  --thrust           使用Thrust库实现
  -?  --help             显示此帮助信息
```

#### 使用前缀和实现"查找重复"

一旦你写好了`exclusive_scan`，就在`scan/scan.cu`中实现`find_repeats`函数。这将涉及编写更多的设备端代码，以及对`exclusive_scan()`的一个或多个调用。你的代码应该将重复元素的列表写入提供的输出指针（位于设备内存中），然后返回输出列表的大小。

当你调用你的`exclusive_scan`实现时，请记住`start`数组的内容会被复制到`output`数组。此外，传递给`exclusive_scan`的数组假定位于`device`内存中。

**评分:** 我们将在随机输入数组上测试你的代码的正确性和性能。

为了检查你的`scan`和`find_repeats`实现的正确性和性能得分，分别运行**`./checker.py scan`**和**`./checker.py find_repeats`**。这样做将产生一个如下的参考表；你的得分仅基于你的代码的性能。为了获得满分，你的代码必须在提供的参考解决方案的20%以内执行。

```
-------------------------
Scan 得分表:
-------------------------
-------------------------------------------------------------------------
| 元素数量   | 参考时间        | 学生时间    | 得分           |
-------------------------------------------------------------------------
| 1000000         | 0.766           | 0.143 (F)       | 0               |
| 10000000        | 8.876           | 0.165 (F)       | 0               |
| 20000000        | 17.537          | 0.157 (F)       | 0               |
| 40000000        | 34.754          | 0.139 (F)       | 0               |
-------------------------------------------------------------------------
|                                   | 总得分:    | 0/5             |
-------------------------------------------------------------------------
```

本作业的这一部分主要是关于获得更多编写CUDA的经验和以数据并行的方式思考，而不是关于代码的性能调整。要在这个作业部分获得全部性能分数，实际上不需要太多的（或者任何）性能调整，只需直接将算法伪代码移植到CUDA即可。然而，有一个技巧：扫描的朴素实现可能会在伪代码中并行循环的每次迭代中启动N个CUDA线程，并在线程内部使用条件执行来确定哪些线程实际需要工作。这样的解决方案不会高效！（考虑上升阶段最后一次外部循环迭代，只有两个线程会做工作）。一个满分的解决方案将只为内部循环的每次迭代启动一个CUDA线程。

**测试框架：** 默认情况下，测试框架在一个伪随机生成的数组上运行，每次程序运行时都是相同的，以便于调试。你可以传递参数`-i random`在随机数组上运行——我们在评分时会这样做。我们鼓励你为程序想出其他输入来帮助评估它。你也可以使用`-n <size>`选项来改变输入数组的长度。

参数`--thrust`将使用[Thrust库](http://thrust.github.io/)的[排他性扫描](https://docs.nvidia.com/cuda/archive/12.2.2/thrust/index.html?highlight=group%20prefix%20sums#prefix-sums)实现。**最多可获得额外2分加分给那些能创建与Thrust竞争的实现的人。**

以上内容翻译成中文。如果你有任何问题或需要进一步的帮助，请告诉我！
